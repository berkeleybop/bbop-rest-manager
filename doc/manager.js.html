<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.2">
  <meta charset="utf-8">
  <title>Source: manager.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: manager.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/** 
 * Generic BBOP manager for dealing with basic generic REST calls.
 * This specific one is designed to be overridden by its subclasses.
 * This one pretty much just uses its incoming resource string as the data.
 * Mostly for testing purposes.
 * 
 * Both a &amp;lt;bbop-rest-response&gt; (or clean error data) and the manager
 * itself (this as anchor) should be passed to the callbacks.
 *
 * @module bbop-rest-manager
 */

// For base.
var us = require(&#x27;underscore&#x27;);
var each = us.each;
var bbop = require(&#x27;bbop-core&#x27;);
var registry = require(&#x27;bbop-registry&#x27;);

// For engines.
var Q = require(&#x27;q&#x27;);
var querystring = require(&#x27;querystring&#x27;);
var jQuery = require(&#x27;jquery&#x27;);
var sync_request = require(&#x27;sync-request&#x27;);

///
/// Base class.
///

/**
 * Contructor for the REST manager.
 * 
 * See also: module:bbop-registry
 * 
 * @constructor
 * @param {Object} response_parser - the response handler class to use for each call
 * @returns {Object} rest manager object
 */
function manager_base(response_handler){
    registry.call(this, [&#x27;success&#x27;, &#x27;error&#x27;]);
    this._is_a = &#x27;bbop-rest-manager.base&#x27;;

    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger.
    this._logger = new bbop.logger(this._is_a);
    //this._logger.DEBUG = true;
    this._logger.DEBUG = false;
    function ll(str){ anchor._logger.kvetch(str); }

    // Handler instance.
    this._response_handler = response_handler;

    // The URL to query.
    this._qurl = null;

    // The argument payload to deliver to the URL.
    this._qpayload = {};

    // The way to do the above.
    this._qmethod = &#x27;GET&#x27;;

    // Whether or not to prevent ajax events from going.
    // This may not be usable, or applicable, to all backends.
    this._safety = false;

    /**
     * Turn on or off the verbose messages. Uses &amp;lt;bbop.logger&gt;, so
     * they should come out everywhere.
     * 
     * @param {Boolean} [p] - true or false for debugging
     * @returns {Boolean} the current state of debugging
     */
    this.debug = function(p){
	if( p === true || p === false ){
	    this._logger.DEBUG = p;
	    // TODO: add debug parameter a la include_highlighting
	}
	return this._logger.DEBUG;
    };

    // The main callback function called after a successful AJAX call in
    // the update function.
    this._run_success_callbacks = function(in_data){
	ll(&#x27;run success callbacks...&#x27;);
	//var response = anchor.(in_data);
	var response = new anchor._response_handler(in_data);
	anchor.apply_callbacks(&#x27;success&#x27;, [response, anchor]);
    };

    // This set is called when we run into a problem.
    this._run_error_callbacks = function(in_data){
	ll(&#x27;run error callbacks...&#x27;);
	var response = new anchor._response_handler(in_data);
	anchor.apply_callbacks(&#x27;error&#x27;, [response, anchor]);
    };

    // Ensure the necessary 
    this._ensure_arguments = function (url, payload, method){
	ll(&#x27;ensure arguments...&#x27;);
	
	// Allow default settings to be set at the moment.
	if( typeof(url) !== &#x27;undefined&#x27; ){ this.resource(url); }
	if( typeof(payload) !== &#x27;undefined&#x27; ){ this.payload(payload); }
	if( typeof(method) !== &#x27;undefined&#x27; ){ this.method(method); }
	
	// Bail if no good resource to try.
	if( ! this.resource() ){
	    throw new Error(&#x27;must have resource defined&#x27;);
	}
    };

    // Apply the callbacks by the status of the response.
    this._apply_callbacks_by_response = function (response){
	ll(&#x27;apply callbacks by response...&#x27;);

	if( response &amp;amp;&amp;amp; response.okay() ){
	    anchor.apply_callbacks(&#x27;success&#x27;, [response, anchor]);
	}else{
	    anchor.apply_callbacks(&#x27;error&#x27;, [response, anchor]);
	}
    };

    /**
     * The base target URL for our operations.
     * 
     * @param {String} [in_url] - update resource target with string
     * @returns {String|null} the url as string (or null)
     */
    this.resource = function(in_url){
	ll(&#x27;resource called with: &#x27; + in_url);

	if( typeof(in_url) !== &#x27;undefined&#x27; &amp;amp;&amp;amp; 
	    bbop.what_is(in_url) === &#x27;string&#x27; ){
	    anchor._qurl = in_url;
	}
	return anchor._qurl;
    };

    /**
     * The information to deliver to the resource.
     * 
     * @param {Object} [payload] - update payload information
     * @returns {Object|null} a copy of the current payload
     */
    this.payload = function(payload){
	ll(&#x27;payload called with: &#x27; + payload);

	if( bbop.is_defined(payload) &amp;amp;&amp;amp; 
	    bbop.what_is(payload) === &#x27;object&#x27; ){
	    anchor._qpayload = payload;
	}
	return bbop.clone(anchor._qpayload);
    };

    /**
     * The method to use to get the resource, as a string.
     * 
     * @param {String} [method] - update aquisition method with string
     * @returns {String|null} the string or null
     */
    this.method = function(method){
	ll(&#x27;method called with: &#x27; + method);

	if( bbop.is_defined(method) &amp;amp;&amp;amp; 
	    bbop.what_is(method) === &#x27;string&#x27; ){
	    anchor._qmethod = method;
	}
	return anchor._qmethod;
    };
}
bbop.extend(manager_base, registry);

///
/// Overridables.
///

/**
 * Output writer for this object/class.
 * See the documentation in &amp;lt;core.js&gt; on &amp;lt;dump&gt; and &amp;lt;to_string&gt;.
 * 
 * @returns {String}  string
 */
manager_base.prototype.to_string = function(){
    return &#x27;[&#x27; + this._is_a + &#x27;]&#x27;;
};

/**
 * Assemble the resource and arguments into a URL string.
 * 
 * May not be appropriate for all subclasses or commands (and probably
 * only useful in the context of GET calls, etc.). Often used as a
 * helper, etc.
 * 
 * Also see: &amp;lt;get_query_url&gt;
 * 
 * @returns {String} url string
 */
manager_base.prototype.assemble = function(){

    // Conditional merging of the remaining variant parts.
    var qurl = this.resource();
    if( ! bbop.is_empty(this.payload()) ){
	var asm = bbop.get_assemble(this.payload());
	qurl = qurl + &#x27;?&#x27; + asm;
    }
    return qurl;
};

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 * 
 * This model class always returns true, with set messages; the
 * &quot;payload&quot; is fed as the argument into the response handler.
 * 
 * What we&#x27;re aiming for is a system that:
 *  - runs callbacks (in order: success, error, return)
 *  - return response
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method - GET, POST, etc.
 * @returns {Object} response (given the incoming payload)
 */
manager_base.prototype.fetch = function(url, payload, method){

    var anchor = this;
    anchor._logger.kvetch(&#x27;called fetch&#x27;);

    this._ensure_arguments(url, payload, method);

    // This is an empty &quot;sync&quot; example, so just return the empty and
    // see.
    var response = new this._response_handler(this.payload());
    response.okay(true);
    response.message(&#x27;empty&#x27;);
    response.message_type(&#x27;success&#x27;);
    
    // Run through the callbacks--naturally always &quot;success&quot; in our
    // case.
    this._apply_callbacks_by_response(response);

    return response;
};

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 * 
 * This model class always returns true, with set messages; the
 * &quot;payload&quot; is fed as the argument into the response handler.
 * 
 * What we&#x27;re aiming for is a system that:
 *  - runs callbacks (in order: success, error, return)
 *  - return promise (delivering response)
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method - GET, POST, etc.
 * @returns {Object} promise for the processed response subclass
 */
manager_base.prototype.start = function(url, payload, method){

    var anchor = this;
    this._ensure_arguments(url, payload, method);

    // No actual async here, but do anyways.
    var deferred = Q.defer();

    // This is an empty &quot;sync&quot; example, so just return the empty and
    // see.
    var response = new this._response_handler(this.payload());
    response.okay(true);
    response.message(&#x27;empty&#x27;);
    response.message_type(&#x27;success&#x27;);
    
    // Run through the callbacks--naturally always &quot;success&quot; in our
    // case.
    this._apply_callbacks_by_response(response);

    deferred.resolve(response);

    return deferred.promise;
};

///
/// Node async engine.
///

/**
 * Contructor for the REST query manager; NodeJS-style.
 * 
 * This is an asynchronous engine, so while both fetch and start will
 * run the callbacks, fetch will return null while start returns a
 * promise for the eventual result. Using the promise is entirely
 * optional--the main method is still considered to be the callbacks.
 * 
 * NodeJS BBOP manager for dealing with remote calls. Remember,
 * this is actually a &quot;subclass&quot; of &amp;lt;bbop.rest.manager&gt;.
 * 
 * See also: {module:bbop-rest-manager#manager}
 *
 * @constructor
 * @param {Object} response_handler
 * @returns {manager_node}
 */
var manager_node = function(response_handler){
    manager_base.call(this, response_handler);
    this._is_a = &#x27;bbop-rest-manager.node&#x27;;

    // Grab an http client.
    this._http_client = require(&#x27;http&#x27;);
    this._url_parser = require(&#x27;url&#x27;);
};
bbop.extend(manager_node, manager_base);

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 *
 * Runs callbacks, returns null.
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method - GET, POST, etc.
 * @returns {null} returns null
 */
manager_node.prototype.fetch = function(url, payload, method){

    var anchor = this;
    anchor._logger.kvetch(&#x27;called fetch&#x27;);

    // Pass off.
    this.start(url, payload, method);

    return null;
};

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 * 
 * What we&#x27;re aiming for is a system that:
 *  - runs callbacks (in order: success, error, return)
 *  - return promise (delivering response)
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method - GET, POST, etc.
 * @returns {Object} promise for the processed response subclass
 */
manager_node.prototype.start = function(url, payload, method){

    var anchor = this;

    this._ensure_arguments(url, payload, method);

    // Our eventual promise.
    var deferred = Q.defer();

    // What to do if an error is triggered.
    function on_error(e) {
	console.log(&#x27;problem with request: &#x27; + e.message);
	var response = new anchor._response_handler(null);
	response.okay(false);
	response.message(e.message);
	response.message_type(&#x27;error&#x27;);
	anchor.apply_callbacks(&#x27;error&#x27;, [response, anchor]);
	deferred.resolve(response);
    }

    // Two things to do here: 1) collect data and 2) what to do with
    // it when we&#x27;re done (create response).
    function on_connect(res){
	//console.log(&#x27;STATUS: &#x27; + res.statusCode);
	//console.log(&#x27;HEADERS: &#x27; + JSON.stringify(res.headers));
	res.setEncoding(&#x27;utf8&#x27;);
	var raw_data = &#x27;&#x27;;
	res.on(&#x27;data&#x27;, function (chunk) {
	    //console.log(&#x27;BODY: &#x27; + chunk);
	    raw_data = raw_data + chunk;
	});
	// Throw to .
	res.on(&#x27;end&#x27;, function () {
	    //console.log(&#x27;END with: &#x27; + raw_data);
	    var response = new anchor._response_handler(raw_data);
	    if( response &amp;amp;&amp;amp; response.okay() ){
		anchor.apply_callbacks(&#x27;success&#x27;, [response, anchor]);
		deferred.resolve(response);
	    }else{
		// Make sure that there is something there to
		// hold on to.
		if( ! response ){
		    response = new anchor._response_handler(null);
		    response.okay(false);
		    response.message_type(&#x27;error&#x27;);
		    response.message(&#x27;null response&#x27;);
		}else{
		    response.message_type(&#x27;error&#x27;);
		    response.message(&#x27;bad response&#x27;);
		}
		anchor.apply_callbacks(&#x27;error&#x27;, [response, anchor]);
		deferred.resolve(response);
	    }
	});
    }

    // http://nodejs.org/api/url.html
    var purl = anchor._url_parser.parse(anchor.resource());
    var req_opts = {
    	//&#x27;hostname&#x27;: anchor.resource(),
    	//&#x27;path&#x27;: &#x27;/amigo/term/GO:0022008/json&#x27;,
	//&#x27;port&#x27;: 80,
	&#x27;method&#x27;: anchor.method()
    };
    // Tranfer the interesting bit over.
    each([&#x27;protocol&#x27;, &#x27;hostname&#x27;, &#x27;port&#x27;, &#x27;path&#x27;], function(purl_prop){
    	if( purl[purl_prop] ){
    	    req_opts[purl_prop] = purl[purl_prop];
    	}
    });

    // Add any payload if it exists. On an empty payload, post_data
    // will still be &#x27;&#x27;, so no real harm done.
    var post_data = querystring.stringify(anchor.payload());
    req_opts[&#x27;headers&#x27;] = {
	&#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,
	&#x27;Content-Length&#x27;: post_data.length
    };

    //console.log(&#x27;req_opts&#x27;, req_opts);

    var req = anchor._http_client.request(req_opts, on_connect);

    // Oh yeah, add the error responder.
    req.on(&#x27;error&#x27;, on_error);
    
    // Write data to request body.
    req.write(post_data);
    req.end();
    
    return deferred.promise;
};

///
/// Node sync engine.
///

/**
 * Contructor for the REST query manager--synchronous in node.
 * 
 * This is an synchronous engine, so while both fetch and start will
 * run the callbacks, fetch will return a response while start returns
 * an instantly resolvable promise. Using the response results is
 * entirely optional--the main method is still considered to be the
 * callbacks.
 * 
 * See also: &amp;lt;bbop.rest.manager&gt;
 * 
 * @constructor
 * @param {Object} response_handler
 * @returns {manager_node_sync}
  */
var manager_node_sync = function(response_handler){
    manager_base.call(this, response_handler);
    this._is_a = &#x27;bbop-rest-manager.node_sync&#x27;;
};
bbop.extend(manager_node_sync, manager_base);

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method - GET, POST, etc.
 * @returns {Object} returns response
 */
manager_node_sync.prototype.fetch = function(url, payload, method){
    var anchor = this;

    this._ensure_arguments(url, payload, method);

    // Grab the data from the server.
    var res = null;
    try {
	res = sync_request(anchor.method(), anchor.resource(), anchor.payload());
    }
    catch(e){
	console.log(&#x27;ERROR in node_sync call, will try to recover&#x27;);
    }
    
    //
    var raw_str = null;
    if( res &amp;amp;&amp;amp; res.statusCode &amp;lt; 400 ){
	raw_str = res.getBody().toString();
    }else if( res &amp;amp;&amp;amp; res.body ){
	raw_str = res.body.toString();
    }else{
	//
    }

    // Process and pick the right callback group accordingly.
    var response = null;
    if( raw_str &amp;amp;&amp;amp; raw_str !== &#x27;&#x27; &amp;amp;&amp;amp; res.statusCode &amp;lt; 400 ){
	response = new anchor._response_handler(raw_str);
	this.apply_callbacks(&#x27;success&#x27;, [response, anchor]);
    }else{
	response = new anchor._response_handler(null);
	this.apply_callbacks(&#x27;error&#x27;, [response, anchor]);
	//throw new Error(&#x27;explody&#x27;);
    }

    return response;
};

/**
 * This is the synchronous data getter for Node (and technically the
 * browser, but never never do that)--probably your best bet right now
 * for scripting.
 * 
 * Works as fetch, except returns an (already resolved) promise.
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method - GET, POST, etc.
 * @returns {Object} returns promise
 */
manager_node_sync.prototype.start = function(url, payload, method){
    var anchor = this;

    var response = anchor.fetch(url, payload, method);

    // .
    var deferred = Q.defer();
    deferred.resolve(response);
    return deferred.promise;
};

///
/// jQuery engine.
///

/**
 * Contructor for the jQuery REST manager
 * 
 * jQuery BBOP manager for dealing with actual ajax calls. Remember,
 * this is actually a &quot;subclass&quot; of {bbop-rest-manager}.
 * 
 * Use &amp;lt;use_jsonp&gt; is you are working against a JSONP service instead
 * of a non-cross-site JSON service.
 * 
 * See also:
 *  &amp;lt;bbop.rest.manager&gt;
 *
 * @constructor
 * @param {Object} response_handler
 * @returns {manager_node_sync}
 */
var manager_jquery = function(response_handler){
    manager_base.call(this, response_handler);
    this._is_a = &#x27;bbop-rest-manager.jquery&#x27;;

    this._use_jsonp = false;
    this._jsonp_callback = &#x27;json.wrf&#x27;;
    this._headers = null;
    
    // Track down and try jQuery.
    var anchor = this;
    //anchor.JQ = new bbop.rest.manager.jquery_faux_ajax();
    try{ // some interpreters might not like this kind of probing
    	if( typeof(jQuery) !== &#x27;undefined&#x27; ){
    	    anchor.JQ = jQuery;
    	    //anchor.JQ = jQuery.noConflict();
    	}
    }catch (x){
	throw new Error(&#x27;unable to find &quot;jQuery&quot; in the environment&#x27;);
    }
};
bbop.extend(manager_jquery, manager_base);

/**
 * Set the jQuery engine to use JSONP handling instead of the default
 * JSON. If set, the callback function to use will be given my the
 * argument &quot;json.wrf&quot; (like Solr), so consider that special.
 * 
 * @param {Boolean} [use_p] - external setter for 
 * @returns {Boolean} boolean
 */
manager_jquery.prototype.use_jsonp = function(use_p){
    var anchor = this;
    if( typeof(use_p) !== &#x27;undefined&#x27; ){
	if( use_p === true || use_p === false ){
	    anchor._use_jsonp = use_p;
	}
    }
    return anchor._use_jsonp;
};

/**
 * Get/set the jQuery jsonp callback string to something other than
 * &quot;json.wrf&quot;.
 * 
 * @param {String} [cstring] - setter string
 * @returns {String} string
 */
manager_jquery.prototype.jsonp_callback = function(cstring){
    var anchor = this;
    if( typeof(cstring) !== &#x27;undefined&#x27;  ){
	anchor._jsonp_callback = cstring;
    }
    return anchor._jsonp_callback;
};

/**
 * Try and control the server with the headers.
 * 
 * @param {Object} [header_set] - hash of headers; jQuery internal default
 * @returns {Object} hash of headers
 */
manager_jquery.prototype.headers = function(header_set){
    var anchor = this;
    if( typeof(header_set) !== &#x27;undefined&#x27; ){
	anchor._headers = header_set;
    }
    return anchor._headers;
};

/**
 * It should combine the URL, payload, and method in the ways
 * appropriate to the subclass engine.
 *
 * Runs callbacks, returns null.
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method - GET, POST, etc.
 * @returns {null} returns null
 */
manager_jquery.prototype.fetch = function(url, payload, method){

    var anchor = this;
    anchor._logger.kvetch(&#x27;called fetch&#x27;);

    // Pass off.
    anchor.start(url, payload, method);

    return null;
};

/**
 * See the documentation in &amp;lt;manager.js&gt; on update to get more
 * of the story. This override function adds functionality for
 * jQuery.
 * 
 * @param {String} [url] - update resource target with string
 * @param {Object} [payload] - object to represent arguments
 * @param {String} [method - GET, POST, etc.
 * @returns {Object} promise for the processed response subclass
 */
manager_jquery.prototype.start = function(url, payload, method){

    var anchor = this;
    
    this._ensure_arguments(url, payload, method);

    // Our eventual promise.
    var deferred = Q.defer();

    // URL and payload (jQuery will just append as arg for GETs).
    var qurl = anchor.resource();
    var pl = anchor.payload();

    // The base jQuery Ajax args we need with the setup we have.
    var jq_vars = {
    	url: qurl,
	data: pl,
    	dataType: &#x27;json&#x27;,
	headers: {
	    &quot;Content-Type&quot;: &quot;application/javascript&quot;,
	    &quot;Accept&quot;: &quot;application/javascript&quot;
	},
    	type: anchor.method()
    };

    // If we&#x27;re going to use JSONP instead of the defaults, set that now.
    if( anchor.use_jsonp() ){
	jq_vars[&#x27;dataType&#x27;] = &#x27;jsonp&#x27;;
	jq_vars[&#x27;jsonp&#x27;] = anchor._jsonp_callback;
    }
    if( anchor.headers() ){
    	jq_vars[&#x27;headers&#x27;] = anchor.headers();
    }

    // What to do if an error is triggered.
    // Remember that with jQuery, when using JSONP, there is no error.
    function on_error(xhr, status, error) {
	var response = new anchor._response_handler(null);
	response.okay(false);
	response.message(error);
	response.message_type(status);
	anchor.apply_callbacks(&#x27;error&#x27;, [response, anchor]);
	deferred.resolve(response);
    }

    function on_success(raw_data, status, xhr){
	var response = new anchor._response_handler(raw_data);
	if( response &amp;amp;&amp;amp; response.okay() ){
	    anchor.apply_callbacks(&#x27;success&#x27;, [response, anchor]);
	    deferred.resolve(response);
	}else{
	    // Make sure that there is something there to
	    // hold on to.
	    if( ! response ){
		response = new anchor._response_handler(null);
		response.okay(false);
		response.message_type(status);
		response.message(&#x27;null response&#x27;);
	    }else{
		response.message_type(status);
		response.message(&#x27;bad response&#x27;);
	    }
	    //anchor.apply_callbacks(&#x27;error&#x27;, [response, anchor]);
	    //anchor.apply_callbacks(&#x27;error&#x27;, [raw_data, anchor]);
	    anchor.apply_callbacks(&#x27;error&#x27;, [response, anchor]);
	    deferred.resolve(response);
	}
    }

    // Setup JSONP for Solr and jQuery ajax-specific parameters.
    jq_vars[&#x27;success&#x27;] = on_success;
    jq_vars[&#x27;error&#x27;] = on_error;
    //done: _callback_type_decider, // decide &amp;amp; run search or reset
    //fail: _run_error_callbacks, // run error callbacks
    //always: function(){} // do I need this?
    anchor.JQ.ajax(jq_vars);

    return deferred.promise;
};

///
/// Exportable body.
///

module.exports = {

    &quot;base&quot; : manager_base,
    &quot;node&quot; : manager_node,
    &quot;node_sync&quot; : manager_node_sync,
    &quot;jquery&quot; : manager_jquery

};
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.2 on August 2, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>